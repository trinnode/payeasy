/**
 * Vulnerability Scanner - TypeScript utilities for scanning and alerting
 * Provides programmatic access to vulnerability data and alerting
 */

export interface ScanResult {
  id: string;
  name: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  description: string;
  affectedComponent: string;
  cveId?: string;
  cvssScore?: number;
  patchAvailable: boolean;
  patchVersion?: string;
  detectedAt: Date;
  source: string;
}

export interface ScanAlert {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  affectedPackage: string;
  recommendedAction: string;
  link?: string;
  createdAt: Date;
  acknowledged?: boolean;
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
}

/**
 * Parse Dependabot scan results
 */
export function parseDependabotResults(data: any[]): ScanResult[] {
  return data.map(item => ({
    id: item.id || `dep-${Date.now()}`,
    name: item.name || item.package_name,
    severity: item.severity?.toLowerCase() || 'low',
    description: item.description || item.vulnerability_description,
    affectedComponent: item.package_name || 'unknown',
    cveId: item.cve_id,
    cvssScore: item.cvss?.score,
    patchAvailable: !!item.security_update,
    patchVersion: item.security_update?.supported_versions?.[0],
    detectedAt: new Date(item.created_at),
    source: 'dependabot',
  } as ScanResult));
}

/**
 * Parse Snyk scan results
 */
export function parseSnykResults(data: any[]): ScanResult[] {
  return data.map(item => ({
    id: item.id || `snyk-${Date.now()}`,
    name: item.name,
    severity: item.severity?.toLowerCase() || 'low',
    description: item.description,
    affectedComponent: item.packageName,
    cveId: item.cveId,
    cvssScore: item.cvssScore,
    patchAvailable: !!item.fixedIn,
    patchVersion: item.fixedIn?.[0],
    detectedAt: new Date(item.introducedDate || Date.now()),
    source: 'snyk',
  } as ScanResult));
}

/**
 * Parse CodeQL results
 */
export function parseCodeQLResults(data: any[]): ScanResult[] {
  return data.map(item => ({
    id: item.id,
    name: item.name,
    severity: (item.severity || 'medium').toLowerCase() as any,
    description: item.description,
    affectedComponent: item.instanceLocation?.physicalLocation?.artifactLocation?.uri || 'unknown',
    patchAvailable: false, // CodeQL results typically require manual fixes
    detectedAt: new Date(),
    source: 'codeql',
  } as ScanResult));
}

/**
 * Generate alert from scan result
 */
export function generateAlert(result: ScanResult): ScanAlert {
  const severityMessages = {
    critical: 'Immediate action required',
    high: 'Priority patch needed',
    medium: 'Schedule patch within 7 days',
    low: 'Include in next update',
    info: 'Monitor for updates',
  };

  return {
    id: `alert-${result.id}`,
    severity: result.severity as any,
    title: `${result.severity.toUpperCase()}: ${result.name}`,
    description: result.description,
    affectedPackage: result.affectedComponent,
    recommendedAction: `${severityMessages[result.severity]} - ${result.patchAvailable ? `Update to ${result.patchVersion}` : 'No patch available yet'}`,
    link: result.cveId ? `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${result.cveId}` : undefined,
    createdAt: result.detectedAt,
  };
}

/**
 * Filter results by severity
 */
export function filterBySeverity(
  results: ScanResult[],
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info'
): ScanResult[] {
  const severityOrder = { critical: 4, high: 3, medium: 2, low: 1, info: 0 };
  const threshold = severityOrder[severity];
  return results.filter(r => severityOrder[r.severity] >= threshold);
}

/**
 * Group results by component
 */
export function groupByComponent(
  results: ScanResult[]
): Record<string, ScanResult[]> {
  return results.reduce(
    (acc, result) => {
      if (!acc[result.affectedComponent]) {
        acc[result.affectedComponent] = [];
      }
      acc[result.affectedComponent].push(result);
      return acc;
    },
    {} as Record<string, ScanResult[]>
  );
}

/**
 * Get patchable results (those with available fixes)
 */
export function getPatchableResults(results: ScanResult[]): ScanResult[] {
  return results.filter(r => r.patchAvailable);
}

/**
 * Get results requiring manual intervention
 */
export function getManualFixRequired(results: ScanResult[]): ScanResult[] {
  return results.filter(r => !r.patchAvailable);
}

/**
 * Sort results by severity and date
 */
export function sortResults(results: ScanResult[]): ScanResult[] {
  const severityOrder = { critical: 4, high: 3, medium: 2, low: 1, info: 0 };

  return [...results].sort((a, b) => {
    const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
    if (severityDiff !== 0) return severityDiff;

    return b.detectedAt.getTime() - a.detectedAt.getTime();
  });
}

/**
 * Check if alert should trigger immediate response
 */
export function requiresImmediateAction(alert: ScanAlert): boolean {
  return alert.severity === 'critical' || alert.severity === 'high';
}

/**
 * Format alert for notification
 */
export function formatAlertForNotification(alert: ScanAlert): string {
  return `
[${alert.severity.toUpperCase()}] ${alert.title}

Package: ${alert.affectedPackage}
Action: ${alert.recommendedAction}

${alert.link ? `More info: ${alert.link}` : ''}
  `.trim();
}

/**
 * Generate webhook payload for alerts
 */
export function generateWebhookPayload(
  alerts: ScanAlert[],
  environment: string
): object {
  const critical = alerts.filter(a => a.severity === 'critical');
  const high = alerts.filter(a => a.severity === 'high');

  return {
    timestamp: new Date().toISOString(),
    environment,
    summary: {
      total: alerts.length,
      critical: critical.length,
      high: high.length,
    },
    alerts: sortAlerts(alerts),
    actionRequired: critical.length > 0 || high.length > 0,
  };
}

/**
 * Sort alerts
 */
export function sortAlerts(alerts: ScanAlert[]): ScanAlert[] {
  const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
  return [...alerts].sort(
    (a, b) => severityOrder[b.severity] - severityOrder[a.severity]
  );
}

/**
 * Calculate risk score (0-100)
 */
export function calculateRiskScore(results: ScanResult[]): number {
  if (results.length === 0) return 0;

  const severityWeights = { critical: 25, high: 15, medium: 5, low: 2, info: 1 };
  const totalScore = results.reduce(
    (sum, r) => sum + (severityWeights[r.severity] || 0),
    0
  );

  // Normalize to 0-100
  return Math.min(100, Math.round(totalScore / results.length));
}

/**
 * Get security status message
 */
export function getSecurityStatus(results: ScanResult[]): string {
  const critical = results.filter(r => r.severity === 'critical').length;
  const high = results.filter(r => r.severity === 'high').length;

  if (critical > 0) return 'ðŸ”´ CRITICAL: Immediate action required';
  if (high > 0) return 'ðŸŸ  HIGH: Priority vulnerabilities detected';
  if (results.length > 0) return 'ðŸŸ¡ MEDIUM: Review recommended';
  return 'ðŸŸ¢ SECURE: No vulnerabilities detected';
}

/**
 * Export results as JSON
 */
export function exportAsJSON(results: ScanResult[]): string {
  return JSON.stringify(results, null, 2);
}

/**
 * Export results as CSV
 */
export function exportAsCSV(results: ScanResult[]): string {
  const headers = ['ID', 'Name', 'Severity', 'Component', 'CVE', 'CVSS', 'Patch Available', 'Detected'];
  const rows = results.map(r => [
    r.id,
    r.name,
    r.severity,
    r.affectedComponent,
    r.cveId || 'N/A',
    r.cvssScore || 'N/A',
    r.patchAvailable ? 'Yes' : 'No',
    r.detectedAt.toISOString(),
  ]);

  const csv = [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
  return csv;
}
